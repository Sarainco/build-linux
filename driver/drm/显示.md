#### 显示驱动开发

#### 1.应用工程师眼里看到的LCD

LCD是由一个个像素点组成：每行有Xres个像素，有yres行，他的分辨率是：xres * yres。

只要我们能控制任一个像素的颜色，就可以在LCD上绘制文字、图片。

##### 1.1 像素的颜色怎么表示

用红绿蓝三颜色来表示，可以用24位数据来表示红绿蓝，也可以用16位等等格式。

* bpp：bit per pixel，每个像素用多少位来表示
* 24bpp：实际上会用到32位，其中8位未使用，其余24位分别用8位表示RGB
* 16bpp: rgb565,rgb555

##### 1.2 怎么把颜色发给LCD

假设每个像素的颜色用16位表示，那么一个LCD的像素点假设有xres*yres个

需要的内存为:xres\*yres\*16/8,也就是要设置所有像素的颜色，需要这么大小的内存。这块内存就被称为framebuffer:

* framebuffer中每块数据对应一个像素。
* 每块数据的大小可能是16位、32位、这和LCD上像素的颜色格式有关
* 设置好LCD硬件后，只需要把颜色数据写入fb即可。

#### 2.驱动工程师眼里看到的LCD

驱动工程师对LCD的理解要深入硬件

* Fb在哪里
* 谁把fb中的数据发送给LCD

##### 2.1 统一的LCD硬件模型

LCD控制器周而复始的从fd中逐一取出每个像素的颜色值发送给LCD



#### 3. Framebuffer驱动程序框架

##### 3.1怎么编写字符设备驱动程序

* 驱动主设备号
* 构造file_operations结构体，填充open/read/write等成员函数
* 注册驱动：register_chrdev(major, name, &fops)
* 入口函数
* 出口函数

##### 3.2 Framebuffer驱动程序框架

分为上下两层：

* fbmem.c:承上启下
* * 实现、注册file_operations结构体
  * 把APP的调用向下转发到具体的硬件驱动程序
* xxx_fb.c：硬件相关的驱动程序
* * 实现、注册fb_info结构体
  * 实现硬件操作

调用关系：

```c
例子1：
app:  open("/dev/fb0", ...)   主设备号: 29, 次设备号: 0
--------------------------------------------------------------
kernel:
         fb_open
         	int fbidx = iminor(inode);
         	struct fb_info *info = = registered_fb[0];


例子2：
app:  read()
---------------------------------------------------------------
kernel:
		fb_read
			int fbidx = iminor(inode);
			struct fb_info *info = registered_fb[fbidx];
			if (info->fbops->fb_read)
				return info->fbops->fb_read(info, buf, count, ppos);
         	
			src = (u32 __iomem *) (info->screen_base + p);
			dst = buffer;
			*dst++ = fb_readl(src++);
			copy_to_user(buf, buffer, c)   
```



##### 3.3 怎么编写Fb驱动程序

* 分配fb_info
* * framebuffer_alloc
* 设置fb_info
* * var
  * fbops
  * 硬件相关操作
* 注册fb_info
* * register_framebuffer



#### 4.写出框架

##### 4.1 分配fb_info

##### 4.2 设置fb_info

* 要设置哪些内容，根据app需要来

##### 4.3 注册fb_info

#### 5.最简单的LCD驱动

Linux驱动 = 驱动框架 + 硬件操作

对于硬件操作，你至少要做这些事情：

* 设置引脚用于LCD
* 阅读LCD手册，阅读LCD控制器手册，根据LCD参数设置LCD控制器（设置控制器时，还需要了解所用主控芯片的时钟系统）
* 分配Framebuffer，把Framebuffer地址高数LCD控制器

#### 6.结合APP分析LCD驱动程序

##### 6.1 open

```c
app:  open("/dev/fb0", ...)   主设备号: 29, 次设备号: 0
--------------------------------------------------------------
kernel:
         fb_open   // fbmem.c
         	struct fb_info *info;
         	info = get_fb_info(fbidx);
			
			if (info->fbops->fb_open) {
				res = info->fbops->fb_open(info,1);   // 硬件相关的驱动
				if (res)
					module_put(info->fbops->owner);
			}    
```

##### 6.2 获得可变信息（含有分辨率）

```c
app:  	ioctl(fd, FBIOGET_VSCREENINFO, &fb_info->var);
-------------------------------------------------------------------------
kernel:
         fb_ioctl   // fbmem.c
         	struct fb_info *info = file_fb_info(file);

         	do_fb_ioctl(info, cmd, arg);
         		var = info->var;     // 硬件相关的驱动设置的
         		ret = copy_to_user(argp, &var, sizeof(var)) ? -EFAULT : 0;
```

##### 6.3 获得固定信息（含有显存信息）

```c
app:  	ioctl(fd, FBIOGET_FSCREENINFO, &fb_info->fix);
-------------------------------------------------------------------------
kernel:
         fb_ioctl   // fbmem.c
         	struct fb_info *info = file_fb_info(file);

         	do_fb_ioctl(info, cmd, arg);
         		fix = info->fix;     // 硬件相关的驱动设置的
         		ret = copy_to_user(argp, &fix, sizeof(fix)) ? -EFAULT : 0;
```

##### 6.4 mmap

```c
app：void *ptr = mmap(0,
			fb_info->var.yres_virtual * fb_info->fix.line_length,
			PROT_WRITE | PROT_READ,
			MAP_SHARED, fd, 0);
-------------------------------------------------------------------------
kernel:
         fb_mmap   // fbmem.c
         	struct fb_info *info = file_fb_info(file);

         	start = info->fix.smem_start;
         	len = info->fix.smem_len;
         	return vm_iomap_memory(vma, start, len);
```

##### 6.5 绘制图片

#### 7.硬件_8080接口LCD时序分析

##### 7.1 接口原理图

###### 7.1.1 8080接口原理图

###### 7.1.2 TFT-RGB接口原理图

##### 7.2 8080接口时序图

#### 9  LCD控制器

查看任何芯片的LCD控制器寄存器时，要记住几个要点：

* 怎么把LCD的信息告诉LCD控制器：即分辨率、行列时序、像素时钟等
* 怎么把显存地址、像素格式告诉LCD控制器

#### 10.分析内核自带的LCD驱动程序_基于IMX6

##### 10.1 驱动程序框架

Linux驱动程序 = 驱动程序框架 + 硬件编程

核心就是：

* 分配fb_info
* 设置fb_info
* 注册fb_info
* 硬件相关的设置

###### 10.1.1 入口函数注册platform_driver

###### 10.1.2 设备树对应节点

###### 10.1.3 probe函数

##### 10.2 编写硬件相关的代码

我们只需要针对IMX6辨别硬件相关的代码，涉及3部分：

	* GPIO设置（LCD引脚、背光引脚）
	* 时钟设置（确定LCD控制器的时钟、根据LCD的DCLK计算相关时钟）
	* LCD控制器本身的设置（Framebuffer的地址，设置fb中的数据格式、lcd数据格式，设置时序）

###### 10.2.1 GPIO设置

有两种方法：

* 直接读写相关寄存器
* 使用设备树，在设备书中设置pinctrl

###### 10.2.2 时钟设置

IMX6的LCD控制器涉及两个时钟：

apb_clk && pix_clk

* 在设备树中指定频率：clock-frequency

```c
       display-timings {
            native-mode = <&timing0>;

             timing0: timing0_1024x768 {
             clock-frequency = <50000000>;
```

* 从设备树中获得dot clock,存入display_timing

```c
ret |= parse_timing_property(np, "clock-frequency", &dt->pixelclock);
```

* 使用display_timing来设置videomode

```c
void videomode_from_timing(const struct display_timing *dt,
			  struct videomode *vm)
{
	vm->pixelclock = dt->pixelclock.typ;
	vm->hactive = dt->hactive.typ;
	vm->hfront_porch = dt->hfront_porch.typ;
	vm->hback_porch = dt->hback_porch.typ;
	vm->hsync_len = dt->hsync_len.typ;

	vm->vactive = dt->vactive.typ;
	vm->vfront_porch = dt->vfront_porch.typ;
	vm->vback_porch = dt->vback_porch.typ;
	vm->vsync_len = dt->vsync_len.typ;

	vm->flags = dt->flags;
}
```

* 使用videomode的值，使用时钟子系统的函数设置时钟：drivers\video\fbdev\mxc\ldb.c

###### 10.2.3 LCD控制器的配置

以设置分辨率为例。

* 在设备树里指定频率：

  * 文件：arch/arm/boot/dts/100ask_imx6ull-14x14.dts

    ```shell
           display-timings {
                native-mode = <&timing0>;
    
                 timing0: timing0_1024x768 {
    				hactive = <1024>;
    	            vactive = <600>;
    
    ```

* 从设备树获得分辨率，存入display_timing

  * 文件：drivers\video\of_display_timing.c

  * 代码：

    ```c
    	ret |= parse_timing_property(np, "hactive", &dt->hactive);
    	ret |= parse_timing_property(np, "vactive", &dt->vactive);
    ```

* 使用display_timing来设置videomode

  * 文件：drivers\video\videomode.c

  * 代码：

    ```c
    void videomode_from_timing(const struct display_timing *dt,
    			  struct videomode *vm)
    {
    	vm->hactive = dt->hactive.typ;
    
        vm->vactive = dt->vactive.typ;
    ```

    

* 根据videomode的值，设置fb_videomode

  * 文件：drivers\video\fbdev\core\fbmon.c

  * 代码：

    ```c
    int fb_videomode_from_videomode(const struct videomode *vm,
    				struct fb_videomode *fbmode)
    {
    	unsigned int htotal, vtotal;
    
    	fbmode->xres = vm->hactive;
    
        fbmode->yres = vm->vactive;
    
    ```

* 根据fb_videomode的值，设置fb_info中的var：

  * 文件：drivers\video\fbdev\core\modedb.c

  * 代码：

    ```c
    void fb_videomode_to_var(struct fb_var_screeninfo *var,
    			 const struct fb_videomode *mode)
    {
    	var->xres = mode->xres;
    	var->yres = mode->yres;
    
    ```

    

* 根据var的分辨率，设置寄存器

  * 文件：drivers\video\fbdev\mxsfb.c

  * 代码：

	writel(TRANSFER_COUNT_SET_VCOUNT(fb_info->var.yres) |
			TRANSFER_COUNT_SET_HCOUNT(fb_info->var.xres),
			host->base + host->devdata->transfer_count);
#### 11.单Buffer的缺点与改进方法

##### 11.1 双Buffer





# 自测题 1

## i.MX6U 的 LCD 控制器是如何从 DDR 中取 framebuffer 数据的？

### 一句话版

> **i.MX6U 的 LCDIF 通过 DMA 按 LCD 时序，从 DDR 中连续读取 framebuffer 数据，并实时转换为 RGB 并行信号输出给 LCD。**

------

### 展开解释（你要真正理解的）

#### 1️⃣ framebuffer 在内存中的形态

在 Linux framebuffer 驱动里：

```
info->screen_base   // 映射到内核虚拟地址
info->fix.smem_start // DDR 物理地址
info->fix.smem_len   // DMA 可访问的显存大小
```

本质上：

```
DDR 中一段连续物理内存
┌────────────────────┐
│ framebuffer memory │  ← LCDIF DMA 读取这里
└────────────────────┘
```

**CPU 写这块内存，LCDIF 只“读”**。

------

#### 2️⃣ LCDIF 干了什么（非常关键）

LCDIF 是一个**“定时 DMA 扫描器”**：

- 内部有 **DMA Engine**
- 被 **pixel clock 驱动**
- 按以下节奏工作：

```
pixel clock tick
   ↓
DMA 取 1 个 pixel
   ↓
输出 RGB 数据
```

------

#### 3️⃣ 行、场扫描是怎么来的？

LCDIF 并不知道“图像”，它只知道：

- 一行多少像素（`hactive`）
- 一帧多少行（`vactive`）
- 每行结束后：
  - 跳过 porch
  - 再继续 DMA 读下一行

逻辑等价于：

```
for (y = 0; y < vactive; y++) {
    for (x = 0; x < hactive; x++) {
        pixel = dma_read(fb_addr);
        output_rgb(pixel);
        fb_addr += bytes_per_pixel;
    }
    fb_addr += line_padding; // stride
}
```

📌 **这也是为什么 `line_length` 非常重要**

------

#### 4️⃣ DMA 从哪知道 framebuffer 地址？

驱动在初始化时：

- 把 `fix.smem_start`
- 写进 LCDIF 的 **DMA 基地址寄存器**

之后：

> ❗ LCDIF 不再关心 Linux，也不关心 fb_info
>  它只是 **按时钟扫内存**

------

### 🔑 关键结论

> **LCD 能亮，不是因为你“画了图”，而是 LCDIF 在“按时序扫内存”。**

------

# 自测题 2

## `smem_len` 为什么经常大于可见分辨率所需大小？

### 一句话版

> **因为 framebuffer 使用的是“虚拟画布”，不仅包含当前显示画面，还包含未显示的缓冲区或对齐空间。**

------

### 拆开讲（这是面试高频）

#### 1️⃣ 理论最小值是多少？

如果：

- 800 × 480
- RGB565（2 bytes）

```
800 × 480 × 2 = 768000 bytes
```

------

#### 2️⃣ 实际 smem_len 通常更大，原因有 4 类

### ✅ 原因一：虚拟分辨率（最常见）

```
var.yres_virtual = var.yres * 2;
```

👉 实际内存：

```
[ Frame 0 ] 800x480
[ Frame 1 ] 800x480
```

这就是：

- 双缓冲
- page flipping
- pan_display 的基础

------

### ✅ 原因二：行对齐（stride）

DMA 通常要求：

- 32 / 64 / 128 字节对齐

所以：

```
line_length >= xres * bpp
```

多出来的是 padding。

------

### ✅ 原因三：缓存 / DMA 对齐

- CMA / DMA 分配的内存：
  - 页对齐（4K）
  - 连续物理内存

**向上取整是常态**。

------

### ✅ 原因四：驱动预留

一些 BSP 驱动会：

- 预留多 buffer
- 或兼容不同分辨率

------

### 🔑 关键结论

> **smem_len 描述的是“DMA 能扫的内存池”，而不是“当前屏幕用了多少”。**

------

# 自测题 3

## 为什么 framebuffer 很难做到 tear-free，而 DRM 可以？

### 一句话版（非常值钱）

> **因为 framebuffer 没有显示控制权的“原子性”，而 DRM 把显示更新变成了“硬件同步的事务”。**

------

### framebuffer 的本质问题

#### 1️⃣ framebuffer 是“共享内存模型”

```
CPU 写 framebuffer
LCDIF 同时读 framebuffer
```

没有任何硬件同步：

```
LCDIF 正在扫第 200 行
CPU 改了第 50 行
→ 撕裂
```

------

#### 2️⃣ framebuffer 缺少三样东西（致命）

❌ 没有 vsync fence
 ❌ 没有 atomic commit
 ❌ 没有 plane / overlay 管理

即使你用：

- 双缓冲
- 软件等待

也只是 **“概率正确”**。

------

### DRM 为什么能解决？

DRM 模型是：

```
prepare buffer
   ↓
atomic commit
   ↓
vsync 到来
   ↓
CRTC 切换 buffer
```

关键是：

> **buffer 切换发生在“帧边界”**

------

### 对 i.MX6U 的现实结论（非常重要）

- i.MX6U **可以跑 DRM**
- 但：
  - IPU-lite 功能弱
  - plane 少
- 所以：
  - framebuffer 学的是 **“显示本质”**
  - DRM 学的是 **“显示架构”**

------

# 三题合在一起的“深入标志”

如果你现在能清晰说出这条话👇：

> **“framebuffer 本质是 CPU 写内存 + LCDIF DMA 按时序扫内存，smem_len 描述的是 DMA 可访问的虚拟画布大小，而撕裂是因为 CPU 与显示扫描之间没有原子同步。”**



