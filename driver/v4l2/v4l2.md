### v4l2

#### 1.数据采集流程

##### 1.1 buffer的管理

使用摄像头时，核心数据时获得数据，所以先讲如何获取数据，即如何得到buffer，摄像头采集数据时，是一帧又一帧的连续采集。所以要申请若干个buffer,驱动程序把数据放入buffer,APP从buffer得到数据，这些buffer可以使用链表来管理。

驱动程序周而复始的做如下事情：

* 从硬件采集到数据
* 把空闲链表取出buffer,把数据存入buffer
* 把含有数据的buffer放入完成链表

APP也会周而复始的做如下事情：

* 监测完成链表，等待它含有buffer
* 从完成链表中取出buffer
* 处理数据
* 把buffer放入空闲链表

##### 1.2 完整的使用流程

参考videolcd，总结摄像头的使用流程

```c
1.iFd = open(strDevName, O_RDWR);//打开设备节点/dev/videox
2. iError = ioctl(iFd, VIDIOC_QUERYCAP, &tV4l2Cap);//查询能力，比如确认他是否时捕获设备，因为有些节点是输出设备，确认它是否支持mmap操作，还是仅支持read/write操作
3. iError = ioctl(iFd, VIDIOC_ENUM_FMT, &tFmtDesc)//枚举它支持的格式
4. iError = ioctl(iFd, VIDIOC_S_FMT, &tV4l2Fmt); //设置格式
5. iError = ioctl(iFd, VIDIOC_REQBUFS, &tV4l2ReqBuffs);//申请buffer,AP可以申请很多个buffer,但驱动不一定能申请到

6.//查询buffer信息，映射到用户态
memset(&tV4l2Buf, 0, sizeof(struct v4l2_buffer));
tV4l2Buf.index = i;
tV4l2Buf.type   = V4L2_BUF_TYPE_VIDEO_CAPTURE;
tV4l2Buf.memory = V4L2_MEMORY_MMAP;
iError = ioctl(iFd, VIDIOC_QUERYBUF, &tV4l2Buf);
if (iError) 
{
    DBG_PRINTF("Unable to query buffer.\n");
    goto err_exit;
}

ptVideoDevice->iVideoBufMaxLen = tV4l2Buf.length;
ptVideoDevice->pucVideBuf[i] = mmap(0 /* start anywhere */ ,
                                    tV4l2Buf.length, PROT_READ, MAP_SHARED, iFd,
                                    tV4l2Buf.m.offset);
if (ptVideoDevice->pucVideBuf[i] == MAP_FAILED) 
{
    DBG_PRINTF("Unable to map buffer\n");
    goto err_exit;
}
} 

7.iError = ioctl(iFd, VIDIOC_QBUF, &tV4l2Buf);//把buffer放入空闲链表，如果申请到N个buffer，就执行n次
8.iError = ioctl(ptVideoDevice->iFd, VIDIOC_STREAMON, &iType);//启动摄像头
9.这里是一个循环：使用poll/select监测buffer,然后从完成链表中取出buffer,处理后在放入空闲链表
poll/select
iRet = ioctl(ptVideoDevice->iFd, VIDIOC_DQBUF, &tV4l2Buf);//从完成链表中取出buffer
iError = ioctl(ptVideoDevice->iFd, VIDIOC_QBUF, &tV4l2Buf);//把buffer放入空闲链表
10.iError = ioctl(ptVideoDevice->iFd, VIDIOC_STREAMOFF, &iType);//停止摄像头

```

#### 2.控制流程

##### 2.1 APP接口

就APP而言，对于这些参数有3套接口：查询或枚举（Query/Enum）、获得、设置。

###### 2.1.1 数据格式

以设置数据格式为例，可以先枚举：

```c
struct v4l2_fmtdesc fmtdesc;
fmtdesc.index = 0;  // 比如从0开始
fmtdesc.type  = V4L2_BUF_TYPE_VIDEO_CAPTURE;  // 指定type为"捕获"
ioctl(vd->fd, VIDIOC_ENUM_FMT, &fmtdesc);

#if 0
/*
 *	F O R M A T   E N U M E R A T I O N
 */
struct v4l2_fmtdesc {
	__u32		    index;             /* Format number      */
	__u32		    type;              /* enum v4l2_buf_type */
	__u32               flags;
	__u8		    description[32];   /* Description string */
	__u32		    pixelformat;       /* Format fourcc      */
	__u32		    reserved[4];
};
#endif
```

还可以获得当前格式：

```c
struct v4l2_format currentFormat;
memset(&currentFormat, 0, sizeof(struct v4l2_format));
currentFormat.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
ioctl(vd->fd, VIDIOC_G_FMT, &currentFormat);

#if 0
struct v4l2_format {
	__u32	 type;
	union {
		struct v4l2_pix_format		pix;     /* V4L2_BUF_TYPE_VIDEO_CAPTURE */
		struct v4l2_pix_format_mplane	pix_mp;  /* V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE */
		struct v4l2_window		win;     /* V4L2_BUF_TYPE_VIDEO_OVERLAY */
		struct v4l2_vbi_format		vbi;     /* V4L2_BUF_TYPE_VBI_CAPTURE */
		struct v4l2_sliced_vbi_format	sliced;  /* V4L2_BUF_TYPE_SLICED_VBI_CAPTURE */
		struct v4l2_sdr_format		sdr;     /* V4L2_BUF_TYPE_SDR_CAPTURE */
		__u8	raw_data[200];                   /* user-defined */
	} fmt;
};

/*
 *	V I D E O   I M A G E   F O R M A T
 */
struct v4l2_pix_format {v4l2_format
	__u32         		width;
	__u32			height;
	__u32			pixelformat;
	__u32			field;		/* enum v4l2_field */
	__u32            	bytesperline;	/* for padding, zero if unused */
	__u32          		sizeimage;
	__u32			colorspace;	/* enum v4l2_colorspace */
	__u32			priv;		/* private data, depends on pixelformat */
	__u32			flags;		/* format flags (V4L2_PIX_FMT_FLAG_*) */
	__u32			ycbcr_enc;	/* enum v4l2_ycbcr_encoding */
	__u32			quantization;	/* enum v4l2_quantization */
	__u32			xfer_func;	/* enum v4l2_xfer_func */
};
#endif
```

也可以设置当前的格式：

```c
struct v4l2_format fmt;
memset(&fmt, 0, sizeof(struct v4l2_format));
fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
fmt.fmt.pix.width = 1024;
fmt.fmt.pix.height = 768;
fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_MJPEG;
fmt.fmt.pix.field = V4L2_FIELD_ANY;
int ret = ioctl(vd->fd, VIDIOC_S_FMT, &fmt);
```

###### 2.1.2 选择输入源

可以获得当前输入源、设置当前输入源：

```c
int value;
ioctl(h->fd,VIDIOC_G_INPUT,&value);  // 读到的value从0开始, 0表示第1个input源

int value = 0;  // 0表示第1个input源
ioctl(h->fd,VIDIOC_S_INPUT,&value)
```

###### 2.1.3 其他参数

如果每一参数都提供一系列的ioctl cmd ，那使用起来很不方便。

对于这些参数，APP使用对应的ID来选中它，然后使用VIDIOC_QUERYCTRL、VIDIOC_G_CTRL、VIDIOC_S_CTRL来操作它。

不同的参数ID值不同。以亮度Brightness为例

* 查询

```c
struct v4l2_queryctrl   qctrl;
memset(&qctrl, 0, sizeof(qctrl));
qctrl.id = V4L2_CID_BRIGHTNESS; // V4L2_CID_BASE+0;
ioctl(fd, VIDIOC_QUERYCTRL, &qctrl);

/*  Used in the VIDIOC_QUERYCTRL ioctl for querying controls */
struct v4l2_queryctrl {
	__u32		     id;
	__u32		     type;	/* enum v4l2_ctrl_type */
	__u8		     name[32];	/* Whatever */
	__s32		     minimum;	/* Note signedness */
	__s32		     maximum;
	__s32		     step;
	__s32		     default_value;
	__u32                flags;
	__u32		     reserved[2];
};

```

* 获得当前值

```c
struct v4l2_control c;
c.id = V4L2_CID_BRIGHTNESS; // V4L2_CID_BASE+0;
ioctl(h->fd, VIDIOC_G_CTRL, &c);


/*
 *	C O N T R O L S
 */
struct v4l2_control {
	__u32		     id;
	__s32		     value;
};
```

* 设置

```c
struct v4l2_control c;
c.id = V4L2_CID_BRIGHTNESS; // V4L2_CID_BASE+0;
c.value = 99;
ioctl(h->fd, VIDIOC_S_CTRL, &c);
```

##### 2.2 理解接口

#### 3.编写APP

##### 3.1 列出帧细节

* VIDIOC_ENUM_FMT：枚举格式
* VIDIOC_ENUM_FRAMESIZES：枚举指定格式的帧大小(即分辨率)

##### 3.2 获取数据

##### 3.3 控制亮度

#### 4 v4l2驱动程序框架

##### 4.1 整体框架

* V4L2设备驱动程序的核心是：file_operations结构体
* * v4l2_file_operations结构体：实现具体的open/read/write/ioctl/mmap操作
  * v4l2_ioctl_ops结构体：v4l2_file_operations结构体一般使用video_ioctl函数，他要调用v4l2_ioctl_ops结构体

###### 4.1.1 v4l2驱动程序注册流程

参考`drivers\media\usb\airspy\airspy.c`：

```c
static struct video_device airspy_template = {
	.name                     = "AirSpy SDR",
	.release                  = video_device_release_empty,
	.fops                     = &airspy_fops,
	.ioctl_ops                = &airspy_ioctl_ops,
};

// 分配/设置video_device结构体
s->vdev = airspy_template;

// 初始化一个v4l2_device结构体(起辅助作用)
/* Register the v4l2_device structure */
s->v4l2_dev.release = airspy_video_release;
ret = v4l2_device_register(&intf->dev, &s->v4l2_dev);

// video_device和4l2_device建立联系
s->vdev.v4l2_dev = &s->v4l2_dev;

// 注册video_device结构体
ret = video_register_device(&s->vdev, VFL_TYPE_SDR, -1);
		__video_register_device
			// 根据次设备号把video_device结构体放入数组
			video_device[vdev->minor] = vdev;
			
			// 注册字符设备驱动程序
			vdev->cdev->ops = &v4l2_fops;
			vdev->cdev->owner = owner;
			ret = cdev_add(vdev->cdev, MKDEV(VIDEO_MAJOR, vdev->minor), 1);
```

###### 4.1.2 ioctl调用流程分析

底层驱动提供了很多ioctl的处理函数

* INFO_FL_STD:标准的，无需特殊的代码来处理，APP的调用可以直达这些处理函数
* INFO_FL_FUNC:这类ioctl需要特殊处理，比如VIDIOC_ENUM_FMT,它需要根据设备的类型分别枚举

简单来说，这两类ioctl的差别在于：

* INFO_FL_STD:APP发出的ioctl直接调用底层的video_device->ioctl_ops->xxx(...)
* INFO_FL_FUNC:APP发出的ioctl，交给`drivers\media\v4l2-core\v4l2-ioctl.c`，它先进行一些特殊处理后，再调用底层的video_device->ioctl_ops->xxxx(....)

##### 4.2 调用流程

##### 4.3 BUFFER的内核实现

###### 4.3.1 videobuffer2缓冲区结构体

分配流程

* 驱动程序初始化时，就构造了vb2_queue,这是buffer的队列，一开始里面没有buffer
* APP调用ioctl VIDIOC_REQBUFS向驱动申请N个buffer
* 驱动程序分配n(n<=N)个vb2_buffer结构体，然后
* * 对于普通摄像头，还分配一个vb2_plane结构体、vb2_vmalloc_buf结构体，最后分配存数据的buffer
  * 对于多平面的摄像头，给每个vb2_buffer分配多个vb2_plane结构体、vb2_vmalloc_buf结构体、存数据的buffer

入队列流程：

* APP调用ioctl VIDIOC_QBUF
* 驱动程序根据index找到vb2_buffer
* 把这个vb2_buffer放入链表vb2_queue.queued_list

硬件驱动接收到数据后，比如URB传输完成后：

* 从链表vb2_queue.queue.queued_list找到（但不移除）vb2_buffer
* 把硬件数据存入vb2_buffer
* 把vb2_buffer放入链表vb2_queue.done_list

出队列流程：

* APP调用ioctl VIDIIC_DQBUF
* 驱动程序从链表vb2_queue.done_list取出并移除第一个vb2_buffer
* 驱动程序也把这个vb2_buffer从链表vb2_queue.queued_list一处

###### 4.3.2 videobuffer2的3个ops

完整的注册流程

```c
static struct video_device airspy_template = {
	.name                     = "AirSpy SDR",
	.release                  = video_device_release_empty,
	.fops                     = &airspy_fops,
	.ioctl_ops                = &airspy_ioctl_ops,
};

/* 构造一个vb2_queue */
	/* Init videobuf2 queue structure */
	s->vb_queue.type = V4L2_BUF_TYPE_SDR_CAPTURE;
	s->vb_queue.io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ;
	s->vb_queue.drv_priv = s;
	s->vb_queue.buf_struct_size = sizeof(struct airspy_frame_buf);
	s->vb_queue.ops = &airspy_vb2_ops;          // vb2_ops, 硬件相关的操作函数
	s->vb_queue.mem_ops = &vb2_vmalloc_memops;  // vb2_mem_ops, 辅助结构体,用于mem ops(alloc、mmap)
	s->vb_queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
	ret = vb2_queue_init(&s->vb_queue);
				q->buf_ops = &v4l2_buf_ops;    // vb2_buf_ops, 用于APP和驱动传递参数

// 分配/设置video_device结构体
s->vdev = airspy_template;
s->vdev.queue = &s->vb_queue;    // 指向前面构造的vb2_queue

// 初始化一个v4l2_device结构体(起辅助作用)
/* Register the v4l2_device structure */
s->v4l2_dev.release = airspy_video_release;
ret = v4l2_device_register(&intf->dev, &s->v4l2_dev);

// video_device和4l2_device建立联系
s->vdev.v4l2_dev = &s->v4l2_dev;

// 注册video_device结构体
ret = video_register_device(&s->vdev, VFL_TYPE_SDR, -1);
		__video_register_device
			// 根据次设备号把video_device结构体放入数组
			video_device[vdev->minor] = vdev;
			
			// 注册字符设备驱动程序
			vdev->cdev->ops = &v4l2_fops;
			vdev->cdev->owner = owner;
			ret = cdev_add(vdev->cdev, MKDEV(VIDEO_MAJOR, vdev->minor), 1);
```

