From a5802293939969a9f13ca6aebf1c8c64fd21a7c1 Mon Sep 17 00:00:00 2001
From: yuji <yujibuzailai_sun@outlook.com>
Date: Wed, 17 Dec 2025 21:36:27 +0800
Subject: [PATCH] add 8 bit emmc and phy driver

---
 .../boot/dts/nxp/imx/imx6ul-14x14-evk.dtsi    | 104 +++++++++---------
 .../boot/dts/nxp/imx/imx6ull-14x14-evk.dts    |  71 ++++++++++++
 drivers/net/ethernet/freescale/fec_main.c     |  13 +++
 drivers/net/phy/smsc.c                        |  62 +++++++++++
 include/linux/phy.h                           |   3 +
 5 files changed, 204 insertions(+), 49 deletions(-)

diff --git a/arch/arm/boot/dts/nxp/imx/imx6ul-14x14-evk.dtsi b/arch/arm/boot/dts/nxp/imx/imx6ul-14x14-evk.dtsi
index 73c9cfbdb..af1903708 100644
--- a/arch/arm/boot/dts/nxp/imx/imx6ul-14x14-evk.dtsi
+++ b/arch/arm/boot/dts/nxp/imx/imx6ul-14x14-evk.dtsi
@@ -138,7 +138,7 @@ spi-4 {
 		status = "okay";
 		sck-gpios = <&gpio5 11 0>;
 		mosi-gpios = <&gpio5 10 0>;
-		cs-gpios = <&gpio5 7 GPIO_ACTIVE_LOW>;
+		/* cs-gpios = <&gpio5 7 GPIO_ACTIVE_LOW>; */
 		num-chipselects = <1>;
 		#address-cells = <1>;
 		#size-cells = <0>;
@@ -150,7 +150,7 @@ gpio_spi: gpio@0 {
 			reg = <0>;
 			registers-number = <1>;
 			spi-max-frequency = <100000>;
-			enable-gpios = <&gpio5 8 GPIO_ACTIVE_LOW>;
+			/* enable-gpios = <&gpio5 8 GPIO_ACTIVE_LOW>; */
 		};
 	};
 
@@ -232,45 +232,7 @@ parallel_from_ov5640: endpoint {
 	};
 };
 
-&fec1 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_enet1>;
-	phy-mode = "rmii";
-	phy-handle = <&ethphy0>;
-	phy-supply = <&reg_peri_3v3>;
-	status = "okay";
-};
-
-&fec2 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_enet2>;
-	phy-mode = "rmii";
-	phy-handle = <&ethphy1>;
-	phy-supply = <&reg_peri_3v3>;
-	status = "okay";
-
-	mdio {
-		#address-cells = <1>;
-		#size-cells = <0>;
 
-		ethphy0: ethernet-phy@2 {
-			compatible = "ethernet-phy-id0022.1560";
-			reg = <2>;
-			micrel,led-mode = <1>;
-			clocks = <&clks IMX6UL_CLK_ENET_REF>;
-			clock-names = "rmii-ref";
-
-		};
-
-		ethphy1: ethernet-phy@1 {
-			compatible = "ethernet-phy-id0022.1560";
-			reg = <1>;
-			micrel,led-mode = <1>;
-			clocks = <&clks IMX6UL_CLK_ENET2_REF>;
-			clock-names = "rmii-ref";
-		};
-	};
-};
 
 &can1 {
 	pinctrl-names = "default";
@@ -428,12 +390,13 @@ &usdhc1 {
 };
 
 &usdhc2 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_usdhc2>;
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc2_8bit>;
+	pinctrl-1 = <&pinctrl_usdhc2_8bit_100mhz>;
+	pinctrl-2 = <&pinctrl_usdhc2_8bit_200mhz>;
+	bus-width = <8>;
+	non-removable;
 	no-1-8-v;
-	broken-cd;
-	keep-power-in-suspend;
-	wakeup-source;
 	status = "okay";
 };
 
@@ -475,7 +438,7 @@ MX6UL_PAD_ENET1_RX_DATA1__ENET1_RDATA01	0x1b0b0
 			MX6UL_PAD_ENET1_TX_EN__ENET1_TX_EN	0x1b0b0
 			MX6UL_PAD_ENET1_TX_DATA0__ENET1_TDATA00	0x1b0b0
 			MX6UL_PAD_ENET1_TX_DATA1__ENET1_TDATA01	0x1b0b0
-			MX6UL_PAD_ENET1_TX_CLK__ENET1_REF_CLK1	0x4001b031
+			MX6UL_PAD_ENET1_TX_CLK__ENET1_REF_CLK1	0x4001b009
 		>;
 	};
 
@@ -490,7 +453,7 @@ MX6UL_PAD_ENET2_RX_DATA1__ENET2_RDATA01	0x1b0b0
 			MX6UL_PAD_ENET2_TX_EN__ENET2_TX_EN	0x1b0b0
 			MX6UL_PAD_ENET2_TX_DATA0__ENET2_TDATA00	0x1b0b0
 			MX6UL_PAD_ENET2_TX_DATA1__ENET2_TDATA01	0x1b0b0
-			MX6UL_PAD_ENET2_TX_CLK__ENET2_REF_CLK2	0x4001b031
+			MX6UL_PAD_ENET2_TX_CLK__ENET2_REF_CLK2	0x4001b009
 		>;
 	};
 
@@ -611,8 +574,6 @@ pinctrl_spi4: spi4grp {
 		fsl,pins = <
 			MX6UL_PAD_BOOT_MODE0__GPIO5_IO10	0x70a1
 			MX6UL_PAD_BOOT_MODE1__GPIO5_IO11	0x70a1
-			MX6UL_PAD_SNVS_TAMPER7__GPIO5_IO07	0x70a1
-			MX6UL_PAD_SNVS_TAMPER8__GPIO5_IO08	0x80000000
 		>;
 	};
 
@@ -695,6 +656,51 @@ MX6UL_PAD_NAND_DATA03__USDHC2_DATA3 0x17059
 		>;
 	};
 
+	pinctrl_usdhc2_8bit: usdhc2grp_8bit {
+		fsl,pins = <
+			MX6UL_PAD_NAND_RE_B__USDHC2_CLK     0x10069
+			MX6UL_PAD_NAND_WE_B__USDHC2_CMD     0x17059
+			MX6UL_PAD_NAND_DATA00__USDHC2_DATA0 0x17059
+			MX6UL_PAD_NAND_DATA01__USDHC2_DATA1 0x17059
+			MX6UL_PAD_NAND_DATA02__USDHC2_DATA2 0x17059
+			MX6UL_PAD_NAND_DATA03__USDHC2_DATA3 0x17059
+			MX6UL_PAD_NAND_DATA04__USDHC2_DATA4 0x17059
+			MX6UL_PAD_NAND_DATA05__USDHC2_DATA5 0x17059
+			MX6UL_PAD_NAND_DATA06__USDHC2_DATA6 0x17059
+			MX6UL_PAD_NAND_DATA07__USDHC2_DATA7 0x17059
+		>;
+	};
+
+	pinctrl_usdhc2_8bit_100mhz: usdhc2grp_8bit_100mhz {
+		fsl,pins = <
+			MX6UL_PAD_NAND_RE_B__USDHC2_CLK     0x100b9
+			MX6UL_PAD_NAND_WE_B__USDHC2_CMD     0x170b9
+			MX6UL_PAD_NAND_DATA00__USDHC2_DATA0 0x170b9
+			MX6UL_PAD_NAND_DATA01__USDHC2_DATA1 0x170b9
+			MX6UL_PAD_NAND_DATA02__USDHC2_DATA2 0x170b9
+			MX6UL_PAD_NAND_DATA03__USDHC2_DATA3 0x170b9
+			MX6UL_PAD_NAND_DATA04__USDHC2_DATA4 0x170b9
+			MX6UL_PAD_NAND_DATA05__USDHC2_DATA5 0x170b9
+			MX6UL_PAD_NAND_DATA06__USDHC2_DATA6 0x170b9
+			MX6UL_PAD_NAND_DATA07__USDHC2_DATA7 0x170b9
+		>;
+	};
+
+	pinctrl_usdhc2_8bit_200mhz: usdhc2grp_8bit_200mhz {
+		fsl,pins = <
+			MX6UL_PAD_NAND_RE_B__USDHC2_CLK     0x100f9
+			MX6UL_PAD_NAND_WE_B__USDHC2_CMD     0x170f9
+			MX6UL_PAD_NAND_DATA00__USDHC2_DATA0 0x170f9
+			MX6UL_PAD_NAND_DATA01__USDHC2_DATA1 0x170f9
+			MX6UL_PAD_NAND_DATA02__USDHC2_DATA2 0x170f9
+			MX6UL_PAD_NAND_DATA03__USDHC2_DATA3 0x170f9
+			MX6UL_PAD_NAND_DATA04__USDHC2_DATA4 0x170f9
+			MX6UL_PAD_NAND_DATA05__USDHC2_DATA5 0x170f9
+			MX6UL_PAD_NAND_DATA06__USDHC2_DATA6 0x170f9
+			MX6UL_PAD_NAND_DATA07__USDHC2_DATA7 0x170f9
+		>;
+	};
+
 	pinctrl_wdog: wdoggrp {
 		fsl,pins = <
 			MX6UL_PAD_LCD_RESET__WDOG1_WDOG_ANY    0x30b0
diff --git a/arch/arm/boot/dts/nxp/imx/imx6ull-14x14-evk.dts b/arch/arm/boot/dts/nxp/imx/imx6ull-14x14-evk.dts
index 74aaa8a56..7959ff7cf 100644
--- a/arch/arm/boot/dts/nxp/imx/imx6ull-14x14-evk.dts
+++ b/arch/arm/boot/dts/nxp/imx/imx6ull-14x14-evk.dts
@@ -16,3 +16,74 @@ &clks {
 	assigned-clocks = <&clks IMX6UL_CLK_PLL3_PFD2>;
 	assigned-clock-rates = <320000000>;
 };
+
+
+&fec1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet1
+			&pinctrl_enet1_reset>;
+	phy-mode = "rmii";
+	phy-handle = <&ethphy0>;
+	phy-reset-gpios = <&gpio5 7 GPIO_ACTIVE_LOW>;
+    phy-reset-duration = <200>;
+	status = "okay";
+};
+
+&fec2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet2
+				&pinctrl_enet2_reset>;
+	phy-mode = "rmii";
+	phy-handle = <&ethphy1>;
+	phy-reset-gpios = <&gpio5 8 GPIO_ACTIVE_LOW>;
+    phy-reset-duration = <200>;
+	status = "okay";
+
+	mdio {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ethphy0: ethernet-phy@0 {
+            compatible = "ethernet-phy-ieee802.3-c22";
+			smsc,disable-energy-detect;
+            reg = <0>;
+         };
+ 
+        ethphy1: ethernet-phy@1 {
+        	compatible = "ethernet-phy-ieee802.3-c22";
+			smsc,disable-energy-detect;
+        	reg = <1>;
+		};
+	};
+};
+
+
+&iomuxc_snvs {
+	pinctrl-names = "default_snvs";
+        pinctrl-0 = <&pinctrl_hog_2>;
+        imx6ul-evk {
+
+		pinctrl_hog_2: hoggrp-2 {
+                        fsl,pins = <
+                            MX6ULL_PAD_SNVS_TAMPER0__GPIO5_IO00      0x80000000
+                        >;
+                };
+
+		/*enet1 reset*/
+		pinctrl_enet1_reset: enet1resetgrp {
+                    	fsl,pins = <
+							/* used for enet1  reset */
+							MX6ULL_PAD_SNVS_TAMPER7__GPIO5_IO07      0x10B0      /* ENET1 RESET */
+                    	>;
+        		};
+
+		/*enet2 reset*/
+		pinctrl_enet2_reset: enet2resetgrp {
+                    	fsl,pins = <
+							/* used for enet2  reset */
+							MX6ULL_PAD_SNVS_TAMPER8__GPIO5_IO08      0x10B0     /* ENET2 RESET */      
+                    	>;
+        		};
+        };
+};
+
diff --git a/drivers/net/ethernet/freescale/fec_main.c b/drivers/net/ethernet/freescale/fec_main.c
index 3222359ac..37da6f198 100644
--- a/drivers/net/ethernet/freescale/fec_main.c
+++ b/drivers/net/ethernet/freescale/fec_main.c
@@ -4390,6 +4390,19 @@ fec_probe(struct platform_device *pdev)
 	int irq_cnt;
 	const struct fec_devinfo *dev_info;
 
+   	/* 设置MX6UL_PAD_ENET1_TX_CLK和
+     * MX6UL_PAD_ENET2_TX_CLK这两个IO的复用寄存器的SION位
+     * 为1。
+     */
+    void __iomem *IMX6U_ENET1_TX_CLK;
+    void __iomem *IMX6U_ENET2_TX_CLK;
+
+    IMX6U_ENET1_TX_CLK = ioremap(0X020E00DC, 4);
+    writel(0X14, IMX6U_ENET1_TX_CLK);
+ 
+    IMX6U_ENET2_TX_CLK = ioremap(0X020E00FC, 4);
+    writel(0X14, IMX6U_ENET2_TX_CLK);
+
 	fec_enet_get_queue_num(pdev, &num_tx_qs, &num_rx_qs);
 
 	/* Init network device */
diff --git a/drivers/net/phy/smsc.c b/drivers/net/phy/smsc.c
index 48487149c..dae9198b5 100644
--- a/drivers/net/phy/smsc.c
+++ b/drivers/net/phy/smsc.c
@@ -23,6 +23,8 @@
 #include <linux/crc16.h>
 #include <linux/etherdevice.h>
 #include <linux/smscphy.h>
+#include <linux/of_gpio.h>
+#include <linux/io.h>
 
 /* Vendor-specific PHY Definitions */
 /* EDPD NLP / crossover time configuration */
@@ -134,6 +136,7 @@ int smsc_phy_config_init(struct phy_device *phydev)
 }
 EXPORT_SYMBOL_GPL(smsc_phy_config_init);
 
+#if 0
 static int smsc_phy_reset(struct phy_device *phydev)
 {
 	int rc = phy_read(phydev, MII_LAN83C185_SPECIAL_MODES);
@@ -152,6 +155,65 @@ static int smsc_phy_reset(struct phy_device *phydev)
 	/* reset the phy */
 	return genphy_soft_reset(phydev);
 }
+#endif
+static int smsc_phy_reset(struct phy_device *phydev)
+{
+	int err, phy_reset;
+	int msec = 1;
+	struct device_node *np;
+
+	if(phydev->addr == 0) /* FEC1  */ {
+		np = of_find_node_by_path("/soc/aips-bus@02100000/ethernet@02188000");
+		if(np == NULL) {
+			return -EINVAL;
+		}
+	}
+
+	if(phydev->addr == 1) /* FEC2  */ {
+		np = of_find_node_by_path("/soc/aips-bus@02000000/ethernet@020b4000");
+		if(np == NULL) {
+			return -EINVAL;
+		}
+	}
+
+	err = of_property_read_u32(np, "phy-reset-duration", &msec);
+	/* A sane reset duration should not be longer than 1s */
+	if (!err && msec > 1000)
+		msec = 1;
+	phy_reset = of_get_named_gpio(np, "phy-reset-gpios", 0);
+	if (!gpio_is_valid(phy_reset))
+		return -EINVAL;
+
+	gpio_direction_output(phy_reset, 0);
+	gpio_set_value(phy_reset, 0);
+	msleep(msec);
+	gpio_set_value(phy_reset, 1);
+
+	int rc = phy_read(phydev, MII_LAN83C185_SPECIAL_MODES);
+	if (rc < 0)
+		return rc;
+
+	/* If the SMSC PHY is in power down mode, then set it
+	 * in all capable mode before using it.
+	 */
+	if ((rc & MII_LAN83C185_MODE_MASK) == MII_LAN83C185_MODE_POWERDOWN) {
+
+		/* set "all capable" mode and reset the phy */
+		rc |= MII_LAN83C185_MODE_ALL;
+		phy_write(phydev, MII_LAN83C185_SPECIAL_MODES, rc);
+	}
+
+	phy_write(phydev, MII_BMCR, BMCR_RESET);
+	/* wait end of reset (max 500 ms) */
+	int timeout = 50000;
+	do {
+		udelay(10);
+		if (timeout-- == 0)
+			return -1;
+		rc = phy_read(phydev, MII_BMCR);
+	} while (rc & BMCR_RESET);
+	return 0;
+}
 
 static int lan87xx_config_aneg(struct phy_device *phydev)
 {
diff --git a/include/linux/phy.h b/include/linux/phy.h
index 3c7634482..915048f3f 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -680,6 +680,9 @@ struct phy_device {
 
 	u32 dev_flags;
 
+	/* Bus address of the PHY (0-31) */
+	int addr;
+
 	phy_interface_t interface;
 	DECLARE_PHY_INTERFACE_MASK(possible_interfaces);
 
-- 
2.34.1

