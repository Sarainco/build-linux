#### 显示驱动开发

#### 1.应用工程师眼里看到的LCD

LCD是由一个个像素点组成：每行有Xres个像素，有yres行，他的分辨率是：xres * yres。

只要我们能控制任一个像素的颜色，就可以在LCD上绘制文字、图片。

##### 1.1 像素的颜色怎么表示

用红绿蓝三颜色来表示，可以用24位数据来表示红绿蓝，也可以用16位等等格式。

* bpp：bit per pixel，每个像素用多少位来表示
* 24bpp：实际上会用到32位，其中8位未使用，其余24位分别用8位表示RGB
* 16bpp: rgb565,rgb555

##### 1.2 怎么把颜色发给LCD

假设每个像素的颜色用16位表示，那么一个LCD的像素点假设有xres*yres个

需要的内存为:xres\*yres\*16/8,也就是要设置所有像素的颜色，需要这么大小的内存。这块内存就被称为framebuffer:

* framebuffer中每块数据对应一个像素。
* 每块数据的大小可能是16位、32位、这和LCD上像素的颜色格式有关
* 设置好LCD硬件后，只需要把颜色数据写入fb即可。

#### 2.驱动工程师眼里看到的LCD

驱动工程师对LCD的理解要深入硬件

* Fb在哪里
* 谁把fb中的数据发送给LCD

##### 2.1 统一的LCD硬件模型

LCD控制器周而复始的从fd中逐一取出每个像素的颜色值发送给LCD



#### 3. Framebuffer驱动程序框架

##### 3.1怎么编写字符设备驱动程序

* 驱动主设备号
* 构造file_operations结构体，填充open/read/write等成员函数
* 注册驱动：register_chrdev(major, name, &fops)
* 入口函数
* 出口函数

##### 3.2 Framebuffer驱动程序框架

分为上下两层：

* fbmem.c:承上启下
* * 实现、注册file_operations结构体
  * 把APP的调用向下转发到具体的硬件驱动程序
* xxx_fb.c：硬件相关的驱动程序
* * 实现、注册fb_info结构体
  * 实现硬件操作

调用关系：

```c
例子1：
app:  open("/dev/fb0", ...)   主设备号: 29, 次设备号: 0
--------------------------------------------------------------
kernel:
         fb_open
         	int fbidx = iminor(inode);
         	struct fb_info *info = = registered_fb[0];


例子2：
app:  read()
---------------------------------------------------------------
kernel:
		fb_read
			int fbidx = iminor(inode);
			struct fb_info *info = registered_fb[fbidx];
			if (info->fbops->fb_read)
				return info->fbops->fb_read(info, buf, count, ppos);
         	
			src = (u32 __iomem *) (info->screen_base + p);
			dst = buffer;
			*dst++ = fb_readl(src++);
			copy_to_user(buf, buffer, c)   
```



##### 3.3 怎么编写Fb驱动程序

* 分配fb_info
* * framebuffer_alloc
* 设置fb_info
* * var
  * fbops
  * 硬件相关操作
* 注册fb_info
* * register_framebuffer



#### 4.写出框架

##### 4.1 分配fb_info

##### 4.2 设置fb_info

* 要设置哪些内容，根据app需要来

##### 4.3 注册fb_info

#### 5.最简单的LCD驱动

Linux驱动 = 驱动框架 + 硬件操作

对于硬件操作，你至少要做这些事情：

* 设置引脚用于LCD
* 阅读LCD手册，阅读LCD控制器手册，根据LCD参数设置LCD控制器（设置控制器时，还需要了解所用主控芯片的时钟系统）
* 分配Framebuffer，把Framebuffer地址高数LCD控制器

#### 6.结合APP分析LCD驱动程序

##### 6.1 open

```c
app:  open("/dev/fb0", ...)   主设备号: 29, 次设备号: 0
--------------------------------------------------------------
kernel:
         fb_open   // fbmem.c
         	struct fb_info *info;
         	info = get_fb_info(fbidx);
			
			if (info->fbops->fb_open) {
				res = info->fbops->fb_open(info,1);   // 硬件相关的驱动
				if (res)
					module_put(info->fbops->owner);
			}    
```

##### 6.2 获得可变信息（含有分辨率）

```c
app:  	ioctl(fd, FBIOGET_VSCREENINFO, &fb_info->var);
-------------------------------------------------------------------------
kernel:
         fb_ioctl   // fbmem.c
         	struct fb_info *info = file_fb_info(file);

         	do_fb_ioctl(info, cmd, arg);
         		var = info->var;     // 硬件相关的驱动设置的
         		ret = copy_to_user(argp, &var, sizeof(var)) ? -EFAULT : 0;
```

##### 6.3 获得固定信息（含有显存信息）

```c
app:  	ioctl(fd, FBIOGET_FSCREENINFO, &fb_info->fix);
-------------------------------------------------------------------------
kernel:
         fb_ioctl   // fbmem.c
         	struct fb_info *info = file_fb_info(file);

         	do_fb_ioctl(info, cmd, arg);
         		fix = info->fix;     // 硬件相关的驱动设置的
         		ret = copy_to_user(argp, &fix, sizeof(fix)) ? -EFAULT : 0;
```

##### 6.4 mmap

```c
app：void *ptr = mmap(0,
			fb_info->var.yres_virtual * fb_info->fix.line_length,
			PROT_WRITE | PROT_READ,
			MAP_SHARED, fd, 0);
-------------------------------------------------------------------------
kernel:
         fb_mmap   // fbmem.c
         	struct fb_info *info = file_fb_info(file);

         	start = info->fix.smem_start;
         	len = info->fix.smem_len;
         	return vm_iomap_memory(vma, start, len);
```

##### 6.5 绘制图片

#### 7.硬件_8080接口LCD时序分析

##### 7.1 接口原理图

###### 7.1.1 8080接口原理图

###### 7.1.2 TFT-RGB接口原理图

##### 7.2 8080接口时序图

#### 9  LCD控制器

查看任何芯片的LCD控制器寄存器时，要记住几个要点：

* 怎么把LCD的信息告诉LCD控制器：即分辨率、行列时序、像素时钟等
* 怎么把显存地址、像素格式告诉LCD控制器

#### 10.分析内核自带的LCD驱动程序_基于IMX6

##### 10.1 驱动程序框架

Linux驱动程序 = 驱动程序框架 + 硬件编程

核心就是：

* 分配fb_info
* 设置fb_info
* 注册fb_info
* 硬件相关的设置

###### 10.1.1 入口函数注册platform_driver

###### 10.1.2 设备树对应节点

###### 10.1.3 probe函数

##### 10.2 编写硬件相关的代码

我们只需要针对IMX6辨别硬件相关的代码，涉及3部分：

	* GPIO设置（LCD引脚、背光引脚）
	* 时钟设置（确定LCD控制器的时钟、根据LCD的DCLK计算相关时钟）
	* LCD控制器本身的设置（Framebuffer的地址，设置fb中的数据格式、lcd数据格式，设置时序）

###### 10.2.1 GPIO设置

有两种方法：

* 直接读写相关寄存器
* 使用设备树，在设备书中设置pinctrl

###### 10.2.2 时钟设置

IMX6的LCD控制器涉及两个时钟：

apb_clk && pix_clk

* 在设备树中指定频率：clock-frequency

```c
       display-timings {
            native-mode = <&timing0>;

             timing0: timing0_1024x768 {
             clock-frequency = <50000000>;
```

* 从设备树中获得dot clock,存入display_timing

```c
ret |= parse_timing_property(np, "clock-frequency", &dt->pixelclock);
```

* 使用display_timing来设置videomode

```c
void videomode_from_timing(const struct display_timing *dt,
			  struct videomode *vm)
{
	vm->pixelclock = dt->pixelclock.typ;
	vm->hactive = dt->hactive.typ;
	vm->hfront_porch = dt->hfront_porch.typ;
	vm->hback_porch = dt->hback_porch.typ;
	vm->hsync_len = dt->hsync_len.typ;

	vm->vactive = dt->vactive.typ;
	vm->vfront_porch = dt->vfront_porch.typ;
	vm->vback_porch = dt->vback_porch.typ;
	vm->vsync_len = dt->vsync_len.typ;

	vm->flags = dt->flags;
}
```

* 使用videomode的值，使用时钟子系统的函数设置时钟：drivers\video\fbdev\mxc\ldb.c

###### 10.2.3 LCD控制器的配置

以设置分辨率为例。

* 在设备树里指定频率：

  * 文件：arch/arm/boot/dts/100ask_imx6ull-14x14.dts

    ```shell
           display-timings {
                native-mode = <&timing0>;
    
                 timing0: timing0_1024x768 {
    				hactive = <1024>;
    	            vactive = <600>;
    
    ```

* 从设备树获得分辨率，存入display_timing

  * 文件：drivers\video\of_display_timing.c

  * 代码：

    ```c
    	ret |= parse_timing_property(np, "hactive", &dt->hactive);
    	ret |= parse_timing_property(np, "vactive", &dt->vactive);
    ```

* 使用display_timing来设置videomode

  * 文件：drivers\video\videomode.c

  * 代码：

    ```c
    void videomode_from_timing(const struct display_timing *dt,
    			  struct videomode *vm)
    {
    	vm->hactive = dt->hactive.typ;
    
        vm->vactive = dt->vactive.typ;
    ```

    

* 根据videomode的值，设置fb_videomode

  * 文件：drivers\video\fbdev\core\fbmon.c

  * 代码：

    ```c
    int fb_videomode_from_videomode(const struct videomode *vm,
    				struct fb_videomode *fbmode)
    {
    	unsigned int htotal, vtotal;
    
    	fbmode->xres = vm->hactive;
    
        fbmode->yres = vm->vactive;
    
    ```

* 根据fb_videomode的值，设置fb_info中的var：

  * 文件：drivers\video\fbdev\core\modedb.c

  * 代码：

    ```c
    void fb_videomode_to_var(struct fb_var_screeninfo *var,
    			 const struct fb_videomode *mode)
    {
    	var->xres = mode->xres;
    	var->yres = mode->yres;
    
    ```

    

* 根据var的分辨率，设置寄存器

  * 文件：drivers\video\fbdev\mxsfb.c

  * 代码：

	writel(TRANSFER_COUNT_SET_VCOUNT(fb_info->var.yres) |
			TRANSFER_COUNT_SET_HCOUNT(fb_info->var.xres),
			host->base + host->devdata->transfer_count);
#### 11.单Buffer的缺点与改进方法

##### 11.1 双Buffer