### 1 异常与中断的概念与处理流程

#### 1.1 中断的引入

cpu在运行过程中，会被各种异常打断，这些异常有：

* 指令未执行
* 指令、数据访问有问题
* SWI（软中断）
* 快中断
* 中断

中断也属于一种异常，导致中断发生的情况有很多，比如：

* 按键
* 定时器
* ADC转换完成
* UART发送完数据、收到数据
* ......

这些众多的中断源，汇集到中断控制器，由中断控制器选择优先级最高的中断并通知CPU。

#### 1.2 中断的处理流程

```bash
# arm对异常（中断）处理过程
1.初始化：
a.设置中断源，让他可以产生中断
b.设置中断控制器（可以屏蔽某个中断，优先级）
c.设置CPU总开关（使能中断）
2.执行其他程序：正常程序
3.产生中断：比如按下按键-->中断控制器-->CPU
4.CPU每执行完一条指令都会检查有无中断/异常产生
5.CPU发现有中断/异常产生，开始处理
对于不同的异常，跳去不同的地址执行程序
这些地址上，只是一条跳转指令，跳去执行某个函数（地址），这个就是异常向量
6.这些函数做什么事情
a.保存现场（各种处理器）
b.处理异常（中断）
分辨中断源，再调用不同的处理函数
c.恢复现场

# 注：3.4.5都是硬件做的
```

#### 1.3 异常向量表

### 2 Linux系统对中断的处理

#### 2.1 进程、线程、中断的核心：栈

##### 2.1.1 ARM处理器程序运行的过程

ARM芯片属于精简指令集计算机（RISC）,它所用的指令比较简单，有如下特点：

* 对 内存只有读、写指令
* 对于数据的运算是在CPU内部实现
* 使用RISC指令的CPU复杂度小一点，易于设计

##### 2.1.2 程序被中断时，怎么保护现场

CPU内部的寄存器很重要，如果要暂停一个程序，中断一个程序，就需要把这些寄存器的值保存下来：这就称为保存现场。

保存在哪里？内存，这块内存就称之为栈。

程序要继续执行，就要先从栈中恢复那些CPU内部寄存器的值。

```bash
a.函数调用
在函数A里调用函数B，实际就是中断函数A的执行。那么需要把函数A调用B之前瞬间的CPU寄存器的值保存到栈里；再去执行函数B，函数B返回之后，就从栈中恢复函数A对应的CPU寄存器值，继续执行。
b.中断处理
进程A正在执行，这时候发生了中断。CPU强制跳到中断异常向量地址去执行，这时候就需要保存进程A被重点瞬间的CPU寄存器值，可以保存在进程A的内核态栈，也可以保存在进程A的内核结构体中。中断处理完毕，要继续运行进程A之前，回复这些值。
c.进程切换
在所谓的多任务操作系统中，我们以为多个程序是同时运行的。如果我们能感知到微秒、纳秒级别的事件，可以保险操作系统让这些程序一次执行一小段时间，进程A的时间用完了，就切换到进程B。
怎么切换？
切换的过程是发生在内核态里的，和中断类似。进程A被切换瞬间的CPU寄存器值保存在某个地方；恢复进程B之前保存的CPU寄存器值，这样就可以运行进程B了。
所以，在中断处理过程中，伴随着进程的保存现场、恢复现场。进程的调度也是使用栈来保存、恢复现场；
```

### 3.进程、线程的概念

* 资源分配的单位是进程，调度的单位是线程。

#### 3.1 Linux系统中对中断处理的演进

Linux系统中有硬件中断，也有软件中断。

对硬件中断的处理有2个原则：不能嵌套，越快越好。

##### 3.1.1 Linux对中断的扩展：硬件中断、软件中断

为了方便理解，可以先认为对硬件中断的处理是用数组来实现的，数组里面存放的是函数指针

a.软件中断何时产生？

由软件决定，对于X号软件中断，只需要把它的flag设置为1就表示发生了该中断。

b.软件中断何时处理？

软件中断，并不是那么十万火急，有空再处理

什么时候有空，不能一直让它等吧

Linux系统中，各种硬件中断频繁发生，至少定时器中断每10ms发生一次，那娶个巧，在处理完硬件中断后，再去处理软件中断。

##### 3.1.2 中断处理原则1：不能嵌套

中断处理函数需要调用C函数，这就需要用到栈。

中断A正在处理的过程中，假设又发生了中断B，那么在栈里要保存A的现场，然后处理B。在处理B的过程中又发生了中断C，那么在栈里要保存B的现场，然后处理C。

如果中断嵌套爆发，那么栈将越来越大，栈终将耗尽。

所以，为了防止这种情况发生，也是为了简单中断的处理，在Linux系统上无法嵌套：即当前中断A没处理完成之前，不会响应另一个中断B（即使他的优先级更高）

##### 3.1.3 中断处理原则2：越快越好

在单芯片系统中，假设中断的处理很慢，那应用程序在这段时间内就无法执行：系统显得卡顿。

在SMP系统中，假设中断处理得很慢，那么正在处理这个中断的CPU上的其他线程也无法执行。

在中断的处理过程中，该CPU是不能进行进程调度的，所以中断的处理要越快越好，尽早让其它中断能被处理---进程调度靠定时器中断来实现。

在Linux系统中使用中断是挺简单的，为某个中断irq注册中断处理函数handler,可以使用resquest_irq函数：

```c
int request_irq(unsigned int irq, irq_handler_t handler, 
unsigned long flags, const char *name,  void *dev)
```

在handler函数中，代码尽可能高效。

##### 3.1.4 要处理的事情实在太多，拆分为：上半部、下半部

中断下半部的实现有很多种方法，主要说两种：tasklet(小任务)、work queue(工作队列)

##### 3.1.5 下半部要做的事情耗时不是很长：tasklet

##### 3.1.6 下半部要做的事情太多并且很复杂：工作队列

##### 3.1.7 threaded irq内核线程

