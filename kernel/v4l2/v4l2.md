### v4l2

#### 1.数据采集流程

##### 1.1 buffer的管理

使用摄像头时，核心数据时获得数据，所以先讲如何获取数据，即如何得到buffer，摄像头采集数据时，是一帧又一帧的连续采集。所以要申请若干个buffer,驱动程序把数据放入buffer,APP从buffer得到数据，这些buffer可以使用链表来管理。

驱动程序周而复始的做如下事情：

* 从硬件采集到数据
* 把空闲链表取出buffer,把数据存入buffer
* 把含有数据的buffer放入完成链表

APP也会周而复始的做如下事情：

* 监测完成链表，等待它含有buffer
* 从完成链表中取出buffer
* 处理数据
* 把buffer放入空闲链表

##### 1.2 完整的使用流程

参考videolcd，总结摄像头的使用流程

```c
1.iFd = open(strDevName, O_RDWR);//打开设备节点/dev/videox
2. iError = ioctl(iFd, VIDIOC_QUERYCAP, &tV4l2Cap);//查询能力，比如确认他是否时捕获设备，因为有些节点是输出设备，确认它是否支持mmap操作，还是仅支持read/write操作
3. iError = ioctl(iFd, VIDIOC_ENUM_FMT, &tFmtDesc)//枚举它支持的格式
4. iError = ioctl(iFd, VIDIOC_S_FMT, &tV4l2Fmt); //设置格式
5. iError = ioctl(iFd, VIDIOC_REQBUFS, &tV4l2ReqBuffs);//申请buffer,AP可以申请很多个buffer,但驱动不一定能申请到

6.//查询buffer信息，映射到用户态
memset(&tV4l2Buf, 0, sizeof(struct v4l2_buffer));
tV4l2Buf.index = i;
tV4l2Buf.type   = V4L2_BUF_TYPE_VIDEO_CAPTURE;
tV4l2Buf.memory = V4L2_MEMORY_MMAP;
iError = ioctl(iFd, VIDIOC_QUERYBUF, &tV4l2Buf);
if (iError) 
{
    DBG_PRINTF("Unable to query buffer.\n");
    goto err_exit;
}

ptVideoDevice->iVideoBufMaxLen = tV4l2Buf.length;
ptVideoDevice->pucVideBuf[i] = mmap(0 /* start anywhere */ ,
                                    tV4l2Buf.length, PROT_READ, MAP_SHARED, iFd,
                                    tV4l2Buf.m.offset);
if (ptVideoDevice->pucVideBuf[i] == MAP_FAILED) 
{
    DBG_PRINTF("Unable to map buffer\n");
    goto err_exit;
}
} 

7.iError = ioctl(iFd, VIDIOC_QBUF, &tV4l2Buf);//把buffer放入空闲链表，如果申请到N个buffer，就执行n次
8.iError = ioctl(ptVideoDevice->iFd, VIDIOC_STREAMON, &iType);//启动摄像头
9.这里是一个循环：使用poll/select监测buffer,然后从完成链表中取出buffer,处理后在放入空闲链表
poll/select
iRet = ioctl(ptVideoDevice->iFd, VIDIOC_DQBUF, &tV4l2Buf);//从完成链表中取出buffer
iError = ioctl(ptVideoDevice->iFd, VIDIOC_QBUF, &tV4l2Buf);//把buffer放入空闲链表
10.iError = ioctl(ptVideoDevice->iFd, VIDIOC_STREAMOFF, &iType);//停止摄像头

```

#### 2.控制流程

##### 2.1 APP接口

就APP而言，对于这些参数有3套接口：查询或枚举（Query/Enum）、获得、设置。

###### 2.1.1 数据格式

以设置数据格式为例，可以先枚举：

```c
struct v4l2_fmtdesc fmtdesc;
fmtdesc.index = 0;  // 比如从0开始
fmtdesc.type  = V4L2_BUF_TYPE_VIDEO_CAPTURE;  // 指定type为"捕获"
ioctl(vd->fd, VIDIOC_ENUM_FMT, &fmtdesc);

#if 0
/*
 *	F O R M A T   E N U M E R A T I O N
 */
struct v4l2_fmtdesc {
	__u32		    index;             /* Format number      */
	__u32		    type;              /* enum v4l2_buf_type */
	__u32               flags;
	__u8		    description[32];   /* Description string */
	__u32		    pixelformat;       /* Format fourcc      */
	__u32		    reserved[4];
};
#endif
```

还可以获得当前格式：

```c
struct v4l2_format currentFormat;
memset(&currentFormat, 0, sizeof(struct v4l2_format));
currentFormat.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
ioctl(vd->fd, VIDIOC_G_FMT, &currentFormat);

#if 0
struct v4l2_format {
	__u32	 type;
	union {
		struct v4l2_pix_format		pix;     /* V4L2_BUF_TYPE_VIDEO_CAPTURE */
		struct v4l2_pix_format_mplane	pix_mp;  /* V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE */
		struct v4l2_window		win;     /* V4L2_BUF_TYPE_VIDEO_OVERLAY */
		struct v4l2_vbi_format		vbi;     /* V4L2_BUF_TYPE_VBI_CAPTURE */
		struct v4l2_sliced_vbi_format	sliced;  /* V4L2_BUF_TYPE_SLICED_VBI_CAPTURE */
		struct v4l2_sdr_format		sdr;     /* V4L2_BUF_TYPE_SDR_CAPTURE */
		__u8	raw_data[200];                   /* user-defined */
	} fmt;
};

/*
 *	V I D E O   I M A G E   F O R M A T
 */
struct v4l2_pix_format {v4l2_format
	__u32         		width;
	__u32			height;
	__u32			pixelformat;
	__u32			field;		/* enum v4l2_field */
	__u32            	bytesperline;	/* for padding, zero if unused */
	__u32          		sizeimage;
	__u32			colorspace;	/* enum v4l2_colorspace */
	__u32			priv;		/* private data, depends on pixelformat */
	__u32			flags;		/* format flags (V4L2_PIX_FMT_FLAG_*) */
	__u32			ycbcr_enc;	/* enum v4l2_ycbcr_encoding */
	__u32			quantization;	/* enum v4l2_quantization */
	__u32			xfer_func;	/* enum v4l2_xfer_func */
};
#endif
```

也可以设置当前的格式：

```c
struct v4l2_format fmt;
memset(&fmt, 0, sizeof(struct v4l2_format));
fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
fmt.fmt.pix.width = 1024;
fmt.fmt.pix.height = 768;
fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_MJPEG;
fmt.fmt.pix.field = V4L2_FIELD_ANY;
int ret = ioctl(vd->fd, VIDIOC_S_FMT, &fmt);
```

###### 2.1.2 选择输入源

可以获得当前输入源、设置当前输入源：

```c
int value;
ioctl(h->fd,VIDIOC_G_INPUT,&value);  // 读到的value从0开始, 0表示第1个input源

int value = 0;  // 0表示第1个input源
ioctl(h->fd,VIDIOC_S_INPUT,&value)
```

###### 2.1.3 其他参数

如果每一参数都提供一系列的ioctl cmd ，那使用起来很不方便。

对于这些参数，APP使用对应的ID来选中它，然后使用VIDIOC_QUERYCTRL、VIDIOC_G_CTRL、VIDIOC_S_CTRL来操作它。

不同的参数ID值不同。以亮度Brightness为例

* 查询

```c
struct v4l2_queryctrl   qctrl;
memset(&qctrl, 0, sizeof(qctrl));
qctrl.id = V4L2_CID_BRIGHTNESS; // V4L2_CID_BASE+0;
ioctl(fd, VIDIOC_QUERYCTRL, &qctrl);

/*  Used in the VIDIOC_QUERYCTRL ioctl for querying controls */
struct v4l2_queryctrl {
	__u32		     id;
	__u32		     type;	/* enum v4l2_ctrl_type */
	__u8		     name[32];	/* Whatever */
	__s32		     minimum;	/* Note signedness */
	__s32		     maximum;
	__s32		     step;
	__s32		     default_value;
	__u32                flags;
	__u32		     reserved[2];
};

```

* 获得当前值

```c
struct v4l2_control c;
c.id = V4L2_CID_BRIGHTNESS; // V4L2_CID_BASE+0;
ioctl(h->fd, VIDIOC_G_CTRL, &c);


/*
 *	C O N T R O L S
 */
struct v4l2_control {
	__u32		     id;
	__s32		     value;
};
```

* 设置

```c
struct v4l2_control c;
c.id = V4L2_CID_BRIGHTNESS; // V4L2_CID_BASE+0;
c.value = 99;
ioctl(h->fd, VIDIOC_S_CTRL, &c);
```

##### 2.2 理解接口

#### 3.编写APP

##### 3.1 列出帧细节

* VIDIOC_ENUM_FMT：枚举格式
* VIDIOC_ENUM_FRAMESIZES：枚举指定格式的帧大小(即分辨率)

##### 3.2 获取数据

##### 3.3 控制亮度

