### v4l2

#### 1.数据采集流程

##### 1.1 buffer的管理

使用摄像头时，核心数据时获得数据，所以先讲如何获取数据，即如何得到buffer，摄像头采集数据时，是一帧又一帧的连续采集。所以要申请若干个buffer,驱动程序把数据放入buffer,APP从buffer得到数据，这些buffer可以使用链表来管理。

驱动程序周而复始的做如下事情：

* 从硬件采集到数据
* 把空闲链表取出buffer,把数据存入buffer
* 把含有数据的buffer放入完成链表

APP也会周而复始的做如下事情：

* 监测完成链表，等待它含有buffer
* 从完成链表中取出buffer
* 处理数据
* 把buffer放入空闲链表

##### 1.2 完整的使用流程

参考videolcd，总结摄像头的使用流程

```c
1.iFd = open(strDevName, O_RDWR);//打开设备节点/dev/videox
2. iError = ioctl(iFd, VIDIOC_QUERYCAP, &tV4l2Cap);//查询能力，比如确认他是否时捕获设备，因为有些节点是输出设备，确认它是否支持mmap操作，还是仅支持read/write操作
3. iError = ioctl(iFd, VIDIOC_ENUM_FMT, &tFmtDesc)//枚举它支持的格式
4. iError = ioctl(iFd, VIDIOC_S_FMT, &tV4l2Fmt); //设置格式
5. iError = ioctl(iFd, VIDIOC_REQBUFS, &tV4l2ReqBuffs);//申请buffer,AP可以申请很多个buffer,但驱动不一定能申请到

6.//查询buffer信息，映射到用户态
memset(&tV4l2Buf, 0, sizeof(struct v4l2_buffer));
tV4l2Buf.index = i;
tV4l2Buf.type   = V4L2_BUF_TYPE_VIDEO_CAPTURE;
tV4l2Buf.memory = V4L2_MEMORY_MMAP;
iError = ioctl(iFd, VIDIOC_QUERYBUF, &tV4l2Buf);
if (iError) 
{
    DBG_PRINTF("Unable to query buffer.\n");
    goto err_exit;
}

ptVideoDevice->iVideoBufMaxLen = tV4l2Buf.length;
ptVideoDevice->pucVideBuf[i] = mmap(0 /* start anywhere */ ,
                                    tV4l2Buf.length, PROT_READ, MAP_SHARED, iFd,
                                    tV4l2Buf.m.offset);
if (ptVideoDevice->pucVideBuf[i] == MAP_FAILED) 
{
    DBG_PRINTF("Unable to map buffer\n");
    goto err_exit;
}
} 

7.iError = ioctl(iFd, VIDIOC_QBUF, &tV4l2Buf);//把buffer放入空闲链表，如果申请到N个buffer，就执行n次
8.iError = ioctl(ptVideoDevice->iFd, VIDIOC_STREAMON, &iType);//启动摄像头
9.这里是一个循环：使用poll/select监测buffer,然后从完成链表中取出buffer,处理后在放入空闲链表
poll/select
iRet = ioctl(ptVideoDevice->iFd, VIDIOC_DQBUF, &tV4l2Buf);//从完成链表中取出buffer
iError = ioctl(ptVideoDevice->iFd, VIDIOC_QBUF, &tV4l2Buf);//把buffer放入空闲链表
10。iError = ioctl(ptVideoDevice->iFd, VIDIOC_STREAMOFF, &iType);//停止摄像头

```

